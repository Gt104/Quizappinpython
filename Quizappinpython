import json
import os
import random
import threading
from typing import List, Dict, Union

QUESTIONS_FILE = "quiz_questions.json"
SCORES_FILE = "scores.json"
TIME_LIMIT = 15  # seconds per question


# ----------------- File Handling -----------------
def load_data(filename: str, default: Union[dict, list] = None) -> Union[dict, list]:
    if os.path.exists(filename):
        try:
            with open(filename, "r", encoding="utf-8") as f:
                return json.load(f)
        except json.JSONDecodeError:
            print(f"‚ö†Ô∏è Error: {filename} is corrupted. Starting fresh.")
            return default if default is not None else []
    return default if default is not None else []


def save_data(filename: str, data: Union[dict, list]) -> None:
    with open(filename, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=4, ensure_ascii=False)


# ----------------- Timed Input -----------------
def timed_input(prompt: str, timeout: int) -> Union[str, None]:
    """Input function with timeout. Returns None if time runs out."""
    user_input = [None]

    def get_input():
        user_input[0] = input(prompt).strip()

    thread = threading.Thread(target=get_input)
    thread.daemon = True
    thread.start()
    thread.join(timeout)

    if thread.is_alive():
        print(f"\n‚è∞ Time's up! You didn't answer in {timeout} seconds.")
        return None
    return user_input[0]


# ----------------- Quiz Functions -----------------
def play_quiz(questions: List[Dict[str, Union[str, List[str]]]]) -> None:
    if not questions:
        print("\n‚ö†Ô∏è No questions available. Please add questions first.\n")
        return

    random.shuffle(questions)
    score = 0
    print("\n=== Starting Timed Quiz ===")
    print(f"You have {TIME_LIMIT} seconds for each question.\n")

    for idx, q in enumerate(questions, start=1):
        print(f"Q{idx}: {q['question']}")
        options = q["options"][:]
        random.shuffle(options)
        for i, opt in enumerate(options, start=1):
            print(f"  {i}. {opt}")

        ans = timed_input("Your answer (number): ", TIME_LIMIT)
        if ans is None:
            print(f"‚ùå Time's up! Correct answer: {q['answer']}")
            continue

        try:
            ans_int = int(ans)
            if 1 <= ans_int <= len(options):
                if options[ans_int - 1].strip().lower() == q["answer"].strip().lower():
                    print("‚úÖ Correct!")
                    score += 1
                else:
                    print(f"‚ùå Wrong! Correct answer: {q['answer']}")
            else:
                print(f"‚ö†Ô∏è Invalid choice! Correct answer: {q['answer']}")
        except ValueError:
            print(f"‚ö†Ô∏è Invalid input! Correct answer: {q['answer']}")

    print(f"\nüéØ Quiz finished! Your score: {score}/{len(questions)}\n")
    save_high_score(score)


def add_question(questions: List[Dict[str, Union[str, List[str]]]]) -> None:
    print("\n=== Add a New Question ===")
    question = input("Enter question: ").strip()

    options = []
    while len(options) < 4:
        opt = input(f"Option {len(options) + 1}: ").strip()
        if opt:
            options.append(opt)
        else:
            print("‚ö†Ô∏è Option cannot be empty!")

    answer = input("Enter correct answer (must match one of the options): ").strip()
    if answer not in options:
        print("‚ö†Ô∏è Error: Answer must be one of the options!")
        return

    questions.append({"question": question, "options": options, "answer": answer})
    save_data(QUESTIONS_FILE, questions)
    print("‚úÖ Question added successfully!\n")


def view_questions(questions: List[Dict[str, Union[str, List[str]]]]) -> None:
    if not questions:
        print("\n‚ö†Ô∏è No questions found.\n")
        return

    print("\n=== All Questions ===")
    for idx, q in enumerate(questions, start=1):
        print(f"\n{idx}. {q['question']}")
        for i, opt in enumerate(q["options"], start=1):
            print(f"   {i}. {opt}")
        print(f"   ‚úÖ Answer: {q['answer']}")


def delete_question(questions: List[Dict[str, Union[str, List[str]]]]) -> None:
    if not questions:
        print("\n‚ö†Ô∏è No questions to delete.\n")
        return

    view_questions(questions)
    try:
        idx = int(input("\nEnter question number to delete: ").strip())
        if 1 <= idx <= len(questions):
            removed = questions.pop(idx - 1)
            save_data(QUESTIONS_FILE, questions)
            print(f"üóëÔ∏è Deleted question: {removed['question']}\n")
        else:
            print("‚ö†Ô∏è Invalid question number.")
    except ValueError:
        print("‚ö†Ô∏è Invalid input.")


# ----------------- Score Handling -----------------
def save_high_score(score: int) -> None:
    scores = load_data(SCORES_FILE, default={"high_score": 0})
    if score > scores.get("high_score", 0):
        scores["high_score"] = score
        save_data(SCORES_FILE, scores)
        print(f"üèÜ New High Score: {score}!\n")
    else:
        print(f"‚≠ê Current High Score: {scores['high_score']}\n")


# ----------------- Main Menu -----------------
def main() -> None:
    questions = load_data(QUESTIONS_FILE, default=[])

    menu = {
        "1": lambda: play_quiz(questions),
        "2": lambda: add_question(questions),
        "3": lambda: view_questions(questions),
        "4": lambda: delete_question(questions),
        "5": lambda: print("üëã Goodbye!") or exit(0),
    }

    try:
        while True:
            print("\n=== QUIZ APP ===")
            print("1. Play Quiz")
            print(f"2. Add Question")
            print("3. View Questions")
            print("4. Delete Question")
            print("5. Exit")

            choice = input("Choose option: ").strip()
            menu.get(choice, lambda: print("‚ö†Ô∏è Invalid option.\n"))()
    except KeyboardInterrupt:
        print("\nüëã Exiting gracefully...")
        exit(0)


if __name__ == "__main__":
    main()
